//
//  HistoryCurrencyViewController.swift
//  CURRENCY
//
//  Created by Stan Liu on 28/03/2018.
//  Copyright (c) 2018 Stan Liu. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import Hero
import SVProgressHUD

protocol HistoryCurrencyDisplayLogic: class {
  func displaySeguePassedCurrency(viewModel: HistoryCurrency.Load.ViewModel)
  func displayFetchedCurrencyHistory(viewModel: HistoryCurrency.Fetch.ViewModel)
  func displayError(viewModel: Base.HandleError.ViewModel)
}

class HistoryCurrencyViewController: UIViewController,
  HistoryCurrencyDisplayLogic,
  PeriodSegmentedControlDelegate,
  LanguageRelodable,
  LoadingControl {
  var interactor: HistoryCurrencyBusinessLogic?
  var router: (NSObjectProtocol & HistoryCurrencyRoutingLogic & HistoryCurrencyDataPassing)?

  // MARK: Object lifecycle
  var displayRates: [Decimal] = []
  var period: Period = Period(name: UserSettings.historyPeriod()) ?? Period.defaultValue

  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
    setup()
  }

  required init?(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)
    setup()
  }

  // MARK: Setup

  private func setup() {
    let viewController = self
    let interactor = HistoryCurrencyInteractor()
    let presenter = HistoryCurrencyPresenter()
    let router = HistoryCurrencyRouter()
    viewController.interactor = interactor
    viewController.router = router
    interactor.presenter = presenter
    presenter.viewController = viewController
    router.viewController = viewController
    router.dataStore = interactor
  }

  // MARK: Routing

  override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
    if let scene = segue.identifier {
      let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
      if let router = router, router.responds(to: selector) {
        router.perform(selector, with: segue)
      }
    }
  }

  // MARK: View lifecycle
  var onView: LoadingContainer {
    return chart
  }
  var indicatorView: UIView {
    return UIActivityIndicatorView(style: .gray)
  }
  @IBOutlet weak var nameLabel: UILabel!
  @IBOutlet weak var divergenceLabel: DivergenceLabel!
  @IBOutlet weak var rateLabel: UILabel!
  @IBOutlet weak var baseLabel: UILabel!
  @IBOutlet weak var chart: LineChart!
  @IBOutlet weak var periodSegmentedControl: PeriodSegmentedControl!
  @IBOutlet weak var containerView: UIView!
  @IBOutlet weak var chartContainerHeightConstraint: NSLayoutConstraint!
  var lastScrollOffset: CGPoint?
  let maxHeaderHeight: CGFloat = 220
  let minHeaderHeight: CGFloat = 0

  override func viewDidLoad() {
    super.viewDidLoad()
    configure()
    configureReachability()
    configureChart()
    configureEmbededViewController()
    configureSegmentedControl()
    configureLabels()

    loadSeguePassedCurrency()
    fetchCurrencyHistory()
    embededVCFetchData()
  }

  func configure() {
    self.isHeroEnabled = true
    divergenceLabel.font = Configuration.Font.numericFont.size(of: 15)

    if #available(iOS 11.0, *) {
      navigationItem.largeTitleDisplayMode = .never
    } else {
      // Fallback on earlier versions
    }
  }

  func configureReachability() {
    let reachabilityWorker = ReachabilityWorker.shared
    reachabilityWorker.whenReachable = { [weak self] (reachability) in
      guard reachability.connection != .none else { return }
      // Do things when connection comes back
      self?.fetchCurrencyHistory()
      self?.embededVCFetchData()
    }
    reachabilityWorker.whenUnreachable = { _ in
      // Do thins notify user has no connection currently
      SVProgressHUD.showError(withStatus: NetworkError.noInternet.localizedDescription)
    }
  }

  func configureEmbededViewController() {
    guard let twBankVC = children.filter({
      return $0 is TWBankViewController
    }).first as? TWBankViewController else { return }
    twBankVC.stockVC?.scrollViewBridge = self
    twBankVC.cashVC?.scrollViewBridge = self
  }

  func configureChart() {
    chart.highlightLastEnabled = true // To highlight last value in the first place.
    chart.fillEnabled = true
    let sourcePrefix = LanguageWorker.shared.localizedString(key: R.string.uI.source_from.key,
                                                             table: .ui)
    chart.sourceDescription = sourcePrefix + " " + "Google Finance"
  }

  func configureSegmentedControl() {
    periodSegmentedControl.delegate = self
    periodSegmentedControl.setCurrentSegmentIndex(period.index, animated: false)
  }

  func configureLabels() {
    nameLabel.font = Configuration.Font.letterFont.size(of: 24)
    baseLabel.font = Configuration.Font.letterFont.size(of: 12)
    rateLabel.font = Configuration.Font.numericFont.size(of: 20)
    nameLabel.textColor = Configuration.Theme.darkGray
    baseLabel.textColor = Configuration.Theme.lightBlue
    rateLabel.textColor = Configuration.Theme.darkBlue
  }

  func reloadLanguage() {
    loadSeguePassedCurrency()
    guard let twBankVC = children.filter({
      return $0 is TWBankViewController
    }).first as? TWBankViewController, twBankVC.isViewLoaded else { return }
    twBankVC.reloadLanguage()
  }

  func embededVCFetchData() {
    guard let twBankVC = children.filter({
      return $0 is TWBankViewController
    }).first as? TWBankViewController, twBankVC.isViewLoaded else { return }
    twBankVC.fetchAll()
  }

  // MARK: Load Segue Passed Currency

  func loadSeguePassedCurrency() {
    let request = HistoryCurrency.Load.Request()
    interactor?.getSeguePassedCurrency(request: request)
  }

  func fetchCurrencyHistory() {
    showLoading()
    let request = HistoryCurrency.Fetch.Request(period: period)
    interactor?.fetchCurrencyHistory(request: request)
  }

  // MARK: Display Title, Fetched Currency History

  func displaySeguePassedCurrency(viewModel: HistoryCurrency.Load.ViewModel) {
    chart.heroID = "chartImageView:\(viewModel.name)" // Hero id should be unique
    nameLabel.heroID = "nameLabel:\(viewModel.name)"
    nameLabel.text = LanguageWorker.shared.localizedString(key: viewModel.name,
                                                           table: .listCurrency)
    let sourcePrefix = LanguageWorker.shared.localizedString(key: R.string.uI.source_from.key,
                                                             table: .ui)
    chart.sourceDescription = sourcePrefix + " " + "Google Finance"
    baseLabel.text = LanguageWorker.shared.localizedString(key: UserSettings.currencyUnit,
                                                           table: .listCurrency)
  }

  func displayFetchedCurrencyHistory(viewModel: HistoryCurrency.Fetch.ViewModel) {
    dismissLoading()
    guard var rate = viewModel.rates.last, viewModel.rates.count > 1 else { return }
    // fix: endIndex - 1 == last, 
    // ex: rate.count is 84, rate.endIndex is 84, but last second need to be 82
    let lastSecondRate = viewModel.rates[viewModel.rates.endIndex - 2]
    var diff = (rate - lastSecondRate)
    let decimalDiff = diff.decimal(after: 4)
    divergenceLabel.bind(tendency: Tendency(amount: decimalDiff), amountString: decimalDiff.stringValue)
    rateLabel.text = rate.decimal(after: 4).stringValue.dollarMark
    chart.subjects = viewModel.rates
    chart.dates = viewModel.dates
    chart.reloadData()
    displayRates = viewModel.rates
  }

  func displayError(viewModel: Base.HandleError.ViewModel) {
    SVProgressHUD.showError(withStatus: viewModel.error.localizedDescription)
    dismissLoading()
  }

  // MARK: PeriodSegmentedControlDelegate

  func segmentedControl(_ segmentedControl: PeriodSegmentedControl, willChangeFromSegment fromSegment: Int) {
    //chart.clean()
  }

  func segmentedControl(_ segmentedControl: PeriodSegmentedControl,
                        didChangeFromSegmentAtIndex fromIndex: Int,
                        toSegmentAtIndex toIndex: Int) {
    //chart.clean()
    for (index, period) in Period.all.enumerated()
      where index == toIndex {
        self.period = period
    }
    fetchCurrencyHistory()
  }
}

// MARK: UIScrollViewBridge

// implement flexible chart
extension HistoryCurrencyViewController: UIScrollViewBridge {

  func setChartHeightConstraint(height: CGFloat) {
    chartContainerHeightConstraint.constant = height
    UIView.animate(withDuration: 0.3,
                   delay: 0.0,
                   usingSpringWithDamping: 0.6,
                   initialSpringVelocity: 0.4,
                   options: .curveEaseIn,
                   animations: {
                    self.view.layoutIfNeeded()
    }, completion: nil)
  }

  func scrollViewDidScroll(_ scrollView: UIScrollView) {
    if scrollView.contentSize.height > maxHeaderHeight {
      defer { // This line will always be executed in the end.
        lastScrollOffset = scrollView.contentOffset
      }
      guard let lastScrollOffset = lastScrollOffset else { return }
      let absoluteTop: CGFloat = 0
      let absoluteBottom: CGFloat = scrollView.contentSize.height - scrollView.frame.size.height
      let scrollDiff = scrollView.contentOffset.y - lastScrollOffset.y
      let isScrollingUP = scrollDiff > 0 && scrollView.contentOffset.y > absoluteTop
      let isScrollingDOWN = scrollDiff < 0 && scrollView.contentOffset.y < absoluteBottom

      var newHeight = chartContainerHeightConstraint.constant
      if isScrollingUP { // is scrolling up
        newHeight = max(minHeaderHeight, chartContainerHeightConstraint.constant - abs(scrollDiff))
      } else if isScrollingDOWN && scrollView.contentOffset.y < maxHeaderHeight
        && chartContainerHeightConstraint.constant < maxHeaderHeight + 1 { // is scrolling down
        newHeight = min(maxHeaderHeight + 1, chartContainerHeightConstraint.constant + abs(scrollDiff))
      }
      // This line is for max of minHeaderHeight or min of maxHeaderHeight
      if newHeight != chartContainerHeightConstraint.constant {
        chartContainerHeightConstraint.constant = newHeight
      }
    }
  }

  // 如果停止手指滑動跟鬆開快速滑動，如果大於就等於 default height
  func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
//    if chartContainerHeightConstraint.constant >= maxHeaderHeight {
//      setChartHeightConstraint(height: maxHeaderHeight)
//      return
//    }
  }

  func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) {
//    if chartContainerHeightConstraint.constant >= maxHeaderHeight {
//      setChartHeightConstraint(height: maxHeaderHeight)
//      return
//    }
  }

  // Trigger by press status bar
  func scrollViewDidScrollToTop(_ scrollView: UIScrollView) {
    setChartHeightConstraint(height: maxHeaderHeight)
  }
}
