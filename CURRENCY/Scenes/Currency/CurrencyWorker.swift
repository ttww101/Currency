//
//  CurrencyWorker.swift
//  CURRENCY
//
//  Created by Stan Liu on 09/11/2017.
//  Copyright (c) 2017 Stan Liu. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

class CurrencyWorker {

  func loadLocalCurrency(by source: String, currency cname: String) -> InvestmentSubject? {
    guard let source = loadLocalSource(source: source),
      let currency = load(currencies: source.currencies, name: cname) else {
      return nil
    }
    let calculatedDivergenceOfSubjects = self.calculateDivergence(of: currency)
    return calculatedDivergenceOfSubjects
  }

  func fetchRemote(completion: @escaping (InvestmentSubject?, Error?) -> Void) {
    API().getBankOfTaiwan(subject: UserSettings.currency, period: .month3) { [unowned self] (currency, error) in
      guard let currency = currency else {
        completion(nil, error)
        return
      }
      var mutableCurrency = currency
      let sortedSubjects = self.sort(by: .oldest, investmentSubject: &mutableCurrency)
      let calculatedDivergenceOfSubjects = self.calculateDivergence(of: sortedSubjects)
      completion(calculatedDivergenceOfSubjects, nil)
    }
  }

  private func loadLocalSource(source: String) -> CurrencySource? {
    return DataManager().load(source: Source.bot(nil, nil))
  }

  private func loadLocalSources() -> [CurrencySource] {
    guard let source = DataManager().load(source: Source.bot(nil, nil)) else {
      return []
    }
    return [source]
  }

  // load fake data
  func loadFakeSource() -> CurrencySource {
//    return CurrencySource(name: "bot",
//                          currencies: [CurrencyFaker.subject])
    return CurrencySource(name: "BKTWTWTP",
                          currencies: [])
  }

  // choose which currency by name
  private func load(currencies curs: [InvestmentSubject], name: String) -> InvestmentSubject? {
    guard let index = curs.index(where: {
      return $0.name == name
    }) else {
      print("couldn't find currency: \(name)'s index")
      return nil
    }
    return curs[index]
  }

  private func sort(by sort: TimeSort, rates: [Trade]) -> [Trade] {
    return rates.sorted {
      if let firstDate = $0.date.toPreciseTime, let secondDate = $1.date.toPreciseTime {
        return sort == TimeSort.latest ? firstDate > secondDate : firstDate < secondDate
      } else if let firstDate = $0.date.toTime, let secondDate = $1.date.toTime {
        return sort == TimeSort.latest ? firstDate > secondDate : firstDate < secondDate
      } else if let firstDate = $0.date.toDate, let secondDate = $1.date.toDate {
        return sort == TimeSort.latest ? firstDate > secondDate : firstDate < secondDate
      } else if let firstDate = $0.date.toMonthDay, let secondDate = $1.date.toMonthDay {
        return sort == TimeSort.latest ? firstDate > secondDate : firstDate < secondDate
      } else {
        return false
      }
    }
  }
  // MARK: To Sort Currency by time

  private func sort(by sort: TimeSort,
                    investmentSubject: inout InvestmentSubject) -> InvestmentSubject {
    var subject = investmentSubject
    subject.cash = self.sort(by: sort, rates: subject.cash)
    subject.stock = self.sort(by: sort, rates: subject.stock)
    return subject
  }

  // MARK: To calculate divergence between two rates

  func compareTrades(`in` array: [Trade]) -> [Trade] {

    return array.compare(handler: { (prev, next) -> Trade in
      var nextBuy = Rate(date: next.buy.date, amount: next.buy.amount)
      let prevBuy = Rate(date: prev.buy.date, amount: prev.buy.amount)
      var nextSell = Rate(date: next.sell.date, amount: next.sell.amount)
      let prevSell = Rate(date: prev.sell.date, amount: prev.sell.amount)
      nextBuy.calculateDivergence(from: prevBuy)
      nextSell.calculateDivergence(from: prevSell)

      return Trade(buy: nextBuy, sell: nextSell)
    }) as [Trade]
  }

  // to caculate the difference between prices depends on day
  func calculateDivergence(of subjects: InvestmentSubject) -> InvestmentSubject {

    let newCash = compareTrades(in: subjects.cash)
    let newStock = compareTrades(in: subjects.stock)

    return InvestmentSubject(name: subjects.name,
                             lastUpdate: subjects.lastUpdate,
                             cash: newCash,
                             stock: newStock)
  }
}
