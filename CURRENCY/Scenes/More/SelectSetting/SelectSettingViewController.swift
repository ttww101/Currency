//
//  SelectSettingViewController.swift
//  ExchangeHelper
//
//  Created by curry on 2019/04/23.
//  Copyright (c) 2018 Meiliang Wen. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol SelectSettingDisplayLogic: class {
  func displayTitle(viewModel: SelectSetting.FetchTitle.ViewModel)
  func displayFetchedOptions(viewModel: SelectSetting.FetchSetting.ViewModel)
  func displayChosenOption(viewModel: SelectSetting.Select.ViewModel)
}

class SelectSettingViewController: UIViewController,
  SelectSettingDisplayLogic,
  UITableViewDelegate,
  UITableViewDataSource,
  LanguageRelodable {

  var interactor: SelectSettingBusinessLogic?
  var router: (NSObjectProtocol & SelectSettingRoutingLogic & SelectSettingDataPassing)?

  // MARK: Object lifecycle

  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
    setup()
  }

  required init?(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)
    setup()
  }

  // MARK: Setup

  private func setup() {
    let viewController = self
    let interactor = SelectSettingInteractor()
    let presenter = SelectSettingPresenter()
    let router = SelectSettingRouter()
    viewController.interactor = interactor
    viewController.router = router
    interactor.presenter = presenter
    presenter.viewController = viewController
    router.viewController = viewController
    router.dataStore = interactor
  }

  // MARK: Routing

  override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
    if let scene = segue.identifier {
      let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
      if let router = router, router.responds(to: selector) {
        router.perform(selector, with: segue)
      }
    }
  }

  // MARK: View lifecycle
  @IBOutlet var tableView: UITableView!

  // the setting handler passed from ListMoreViewController
  var applyConfigurationHandler: ((String?) -> Void)?
  var optionKeys: [String] = []
  var optionValues: [String] = []
  var currentOption: String = ""
  var chosenOption: String?

  override func viewDidLoad() {
    super.viewDidLoad()

    configure()
    configureTableView()

    fetchPreferenceOptions()
  }

  func configure() {
    let rightBarBtnLocalizedTitle = LanguageWorker.shared.localizedString(key: R.string.uI.done.key,
                                                                          table: .ui)
    navigationItem.rightBarButtonItem = UIBarButtonItem(title: rightBarBtnLocalizedTitle,
                                                        style: UIBarButtonItem.Style.plain,
                                                        target: self,
                                                        action: #selector(SelectSettingViewController.applyConfiguration))
    if #available(iOS 11.0, *) {
      navigationItem.largeTitleDisplayMode = .never
    } else {
      // Fallback on earlier versions
    }
    fetchTitle()
  }

  func configureTableView() {
    tableView.delegate = self
    tableView.dataSource = self
    tableView.rowHeight = 60
    tableView.separatorColor = KKConfiguration.Theme.lightBlue
    tableView.separatorInset = UIEdgeInsets(top: 0, left: 0, bottom: 0, right: 0)
    tableView.register(R.nib.moreCell(), forCellReuseIdentifier: R.reuseIdentifier.moreCell.identifier)
  }

  func reloadLanguage() {
    configure()
  }

  // Fetch Title
  func fetchTitle() {
    let request = SelectSetting.FetchTitle.Request()
    interactor?.fetchTitle(request: request)
  }

  // Fetch preference options from DataStore which passed by previous ListMoreViewController
  func fetchPreferenceOptions() {
    let request = SelectSetting.FetchSetting.Request()
    interactor?.fetchOptions(request: request)
  }

  @objc func applyConfiguration() {
    guard let applyHandler = applyConfigurationHandler else {
      fatalError("Need to has applyConfigurationHandler from praent view controller")
    }
    if let chosenOption = self.chosenOption {
      applyHandler(chosenOption)
    }
    if let navi = self.navigationController {
      navi.popViewController(animated: true)
    }
  }

  // Fetch Setting Options

  func displayTitle(viewModel: SelectSetting.FetchTitle.ViewModel) {
    title = viewModel.displayTitle
  }

  func displayFetchedOptions(viewModel: SelectSetting.FetchSetting.ViewModel) {
    self.applyConfigurationHandler = viewModel.applyConfigurationHandler
    self.optionKeys = viewModel.optionKeys
    self.optionValues = viewModel.optionValues
    self.currentOption = viewModel.currentOption
    tableView.reloadData()
  }

  func displayChosenOption(viewModel: SelectSetting.Select.ViewModel) {
  }

  // MARK: UITableViewDelegate

  func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
    // reset all
    for sectionSqeuence in 0..<tableView.numberOfSections {
      for rowSequence in 0..<tableView.numberOfRows(inSection: sectionSqeuence) {
        if let cell = tableView.cellForRow(at: IndexPath(row: rowSequence, section: sectionSqeuence)) {
          cell.accessoryType = .none
        }
      }
    }
    // select by selection
    guard let cell = tableView.cellForRow(at: indexPath) else {
      return
    }
    cell.accessoryType = .checkmark
    chosenOption = optionKeys[indexPath.row]
  }

  // MARK: UITableViewDataSource

  func numberOfSections(in tableView: UITableView) -> Int {
    return 1
  }

  func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
    return optionValues.count
  }

  func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
    guard let cell = tableView.dequeueReusableCell(withIdentifier: R.reuseIdentifier.moreCell.identifier) as? MoreCell else {
      return UITableViewCell()
    }
    let optionValue = optionValues[indexPath.row]
    let optionKey = optionKeys[indexPath.row]
    cell.nameLabel.text = optionValue
    cell.variedView.bind(type: .none, content: nil)
    cell.selectionStyle = .none
    cell.accessoryType = (chosenOption ?? currentOption) == optionKey ? .checkmark : .none // if chosenOption is nil, show currentOption
    //print("optionKey: \(optionKey)")
    //print("currentOption: \(currentOption)")
    cell.tintColor = KKConfiguration.Theme.green
    return cell
  }
}
