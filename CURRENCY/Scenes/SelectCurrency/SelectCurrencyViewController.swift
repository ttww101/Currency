//
//  SelectSubjectViewController.swift
//  CURRENCY
//
//  Created by Stan Liu on 21/01/2018.
//  Copyright (c) 2018 Stan Liu. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import SVProgressHUD

protocol SelectCurrencyDisplayLogic: class {
  func displaySources(viewModel: SelectCurrency.SourceOptions.ViewModel)
  func displayCurrencies(viewModel: SelectCurrency.CurrencyOptions.ViewModel)
}

class SelectCurrencyViewController: UIViewController,
  SelectCurrencyDisplayLogic,
  NeonTableViewDelegate,
  NeonTableViewDataSource {
  var interactor: SelectCurrencyBusinessLogic?
  var router: (NSObjectProtocol & SelectCurrencyRoutingLogic & SelectCurrencyDataPassing)?

  // MARK: Display
  //var displaySources: [SelectCurrency.SourceOptions.ViewModel.DisplaySelectSource] = []
  //var displayCurrencies: [SelectCurrency.CurrencyOptions.ViewModel.DisplaySelectCurrency] = []
  var displaySources: [String] = []
  var displayCurrencies: [String] = []
  var userSelectedSource: String {
    return UserSettings.source
  }
  var userSelectedCurrency: String {
    return UserSettings.currency
  }

  // MARK: UI
  lazy var optionView: OptionView = {
    let _optionView = OptionView()
    return _optionView
  }()

  lazy var sourceTableView: NeonTableView = {
    var _tableView = NeonTableView(frame: .zero)
    _tableView.neonDelegate = self
    _tableView.neonDataSource = self
    _tableView.roundingSide = .right
    return _tableView
  }()

  lazy var subjectTableView: NeonTableView = {
    var _tableView = NeonTableView(frame: .zero)
    _tableView.neonDelegate = self
    _tableView.neonDataSource = self
    _tableView.roundingSide = .left
    return _tableView
  }()

  // MARK: Object lifecycle

  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
    setup()
  }

  required init?(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)
    setup()
  }

  // MARK: Setup

  private func setup() {
    let viewController = self
    let interactor = SelectCurrencyInteractor()
    let presenter = SelectCurrencyPresenter()
    let router = SelectCurrencyRouter()
    viewController.interactor = interactor
    viewController.router = router
    interactor.presenter = presenter
    presenter.viewController = viewController
    router.viewController = viewController
    router.dataStore = interactor
  }

  // MARK: Routing

  override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
    if let scene = segue.identifier {
      let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
      if let router = router, router.responds(to: selector) {
        router.perform(selector, with: segue)
      }
    }
  }

  // MARK: View lifecycle

  override func viewDidLoad() {
    super.viewDidLoad()
    // viewController setup
    configure()
    configureOptionView()
    configureNeonTableViews()

    isViewAppeared = true
    setNeedsStatusBarAppearanceUpdate()

    // fetch data
    loadSources()
  }

  // MARK: UI Setup

  var isViewAppeared: Bool = false

  override func viewDidDisappear(_ animated: Bool) {
    super.viewDidDisappear(animated)
    isViewAppeared = false
    setNeedsStatusBarAppearanceUpdate()
  }

  // override this could controll status bar show
  override var prefersStatusBarHidden: Bool {
    //return isViewAppeared
    return false
  }

  // MARK: Setup ViewController
  func configure() {
    view.backgroundColor = Configuration.Theme.white
  }

  // MARK: Setup Neon TableViews

  func configureNeonTableViews() {
    view.addSubview(sourceTableView)
    view.addSubview(subjectTableView)

    sourceTableView.translatesAutoresizingMaskIntoConstraints = false
    subjectTableView.translatesAutoresizingMaskIntoConstraints = false

    sourceTableView.topAnchor.constraint(equalTo: optionView.bottomAnchor).isActive = true
    sourceTableView.leftAnchor.constraint(equalTo: view.leftAnchor).isActive = true
    sourceTableView.bottomAnchor.constraint(equalTo: view.bottomAnchor).isActive = true
    sourceTableView.rightAnchor.constraint(equalTo: subjectTableView.leftAnchor, constant: -5).isActive = true
    subjectTableView.topAnchor.constraint(equalTo: sourceTableView.topAnchor).isActive = true
    subjectTableView.bottomAnchor.constraint(equalTo: sourceTableView.bottomAnchor).isActive = true
    subjectTableView.rightAnchor.constraint(equalTo: view.rightAnchor).isActive = true
    sourceTableView.widthAnchor.constraint(equalTo: subjectTableView.widthAnchor, multiplier: 1).isActive = true
    let statusHeight: CGFloat = 0
    sourceTableView.contentInset = UIEdgeInsets(top: -statusHeight, left: 0, bottom: 0, right: 0)
    subjectTableView.contentInset = UIEdgeInsets(top: -statusHeight, left: 0, bottom: 0, right: 0)
  }

  // MARK: Setup OptionView

  func configureOptionView() {
    view.addSubview(optionView)
    optionView.translatesAutoresizingMaskIntoConstraints = false
    //let statusHeight = UIApplication.shared.statusBarFrame.height
    //optionView.topAnchor.constraint(equalTo: view.topAnchor, constant: statusHeight).isActive = true
    optionView.topAnchor.constraint(equalTo: view.topAnchor).isActive = true
    optionView.leftAnchor.constraint(equalTo: view.leftAnchor).isActive = true
    optionView.rightAnchor.constraint(equalTo: view.rightAnchor).isActive = true
    optionView.heightAnchor.constraint(equalToConstant: 80).isActive = true

    // setup optionview confirm and cancel
    optionView.confirmHandler = { [unowned self] in
      guard // check if display source, currency count bigger than selectedIndex to prevent fatal error: out of bounds
        let selectedSourceIndex = self.sourceTableView.indexPathForSelectedRow,
        self.displaySources.count > selectedSourceIndex.row
        else {
          // Show error
          let errorMessage = LanguageWorker.shared.localizedString(key: R.string.uI.missing_selected_source.key,
                                                                   table: .ui)
          SVProgressHUD.showError(withStatus: errorMessage)
          return
      }
      guard
        let selectedCurrencyIndex = self.subjectTableView.indexPathForSelectedRow,
          self.displayCurrencies.count > selectedCurrencyIndex.row
        else {
          // Show error
          let errorMessage = LanguageWorker.shared.localizedString(key: R.string.uI.missing_selected_currency.key,
                                                                   table: .ui)
          SVProgressHUD.showError(withStatus: errorMessage)
          return
      }
      let source = self.displaySources[selectedSourceIndex.row]
      let currency = self.displayCurrencies[selectedCurrencyIndex.row]

      // if user not select another source, currency, do nothing
      guard source == UserSettings.source && currency == UserSettings.currency  else {
        UserSettings.setSource(name: source)
        UserSettings.setCurrency(name: currency)
        self.router?.routeToCurrency(segue: nil)
        return
      }
      self.dismiss(animated: true, completion: nil)
    }

    optionView.cancelHandler = { [unowned self] in
      self.dismiss(animated: true, completion: nil)
    }
  }

  // MARK: <<< the stps to load data source >>>
  // loadSource -> ... -> displaySources -> userSettingSelectSource ->
  // -> (sourceTableView.selectRow(row: animated:) -> neonDelegate.didSelect
  //                                               -> UITableView.didSelect

  // MARK: Load sources, currencies

  func loadSources() {
    let request = SelectCurrency.SourceOptions.Request()
    interactor?.fetchSources(request: request)
  }

  func loadCurrencies(source: String) {
    let request = SelectCurrency.CurrencyOptions.Request()
    interactor?.fetchCurrencies(request: request)
  }

  // MARK: User Settings select
  // select which source and currency depends user setting or user select

  func userSettingsSelectSource(_ name: String) {
    guard let index = displaySources.index(where: {
      return $0 == name
    }) else {
      print("couldn't find display source: \(name)'s index")
      return
    }
    sourceTableView.selectRow(at: index, animated: false)
  }

  func userSettingsSelectCurrency(_ name: String) {
    guard let index = displayCurrencies.index(where: {
      return $0 == name
    }) else {
      print("couldn't find display currency: \(name)'s index")
      return
    }
    subjectTableView.selectRow(at: index, animated: false)
  }

  // MARK: SelectSubjectPresenter

  func displaySources(viewModel: SelectCurrency.SourceOptions.ViewModel) {
    displaySources = viewModel.displaySources
    sourceTableView.reloadData()
    userSettingsSelectSource(userSelectedSource)
  }

  func displayCurrencies(viewModel: SelectCurrency.CurrencyOptions.ViewModel) {
    let currencies = viewModel.displayCurrencies
    displayCurrencies = currencies
    subjectTableView.reloadData()
    userSettingsSelectCurrency(userSelectedCurrency)
  }

  // MARK: NeonTableViewDelegate

  func neonTableView(_ neonTableView: NeonTableView, heightForRow index: Int) -> CGFloat {
    return min(30, (neonTableView.frame.height) / CGFloat(displayCurrencies.count))
  }

  func neonTableView(_ neonTableView: NeonTableView, didSelectAt index: Int) {
    guard neonTableView == subjectTableView else {
      // reload currency when sourceTableView was selecting
      let source = displaySources[index]
      loadCurrencies(source: source)
      return
    }
    // select currency
  }

  func textAlignment(_ neonTableView: NeonTableView) -> NSTextAlignment {
    guard neonTableView == subjectTableView else {
      return .right
    }
    return .left
  }


  // MARK: NeonTableViewDataSource

  func numberOfRows(_ neonTableView: NeonTableView) -> Int {
    guard neonTableView == subjectTableView else {
      return displaySources.count
    }
    return displayCurrencies.count
  }

  func neonTableView(_ neonTableView: NeonTableView, valueOfRows row: Int) -> String {
    guard neonTableView == subjectTableView else {
      return LanguageWorker.shared.localizedString(key: displaySources[row],
                                                   table: .listCurrency)
    }
    return LanguageWorker.shared.localizedString(key: displayCurrencies[row],
                                                 table: .listCurrency)
  }
}
